#!/usr/bin/env ruby
require 'open3'
require 'readline'
mode = ARGV.shift
case mode
when "record"
  cmd = ["rr", "record"] + ARGV
  system(*cmd)
  exit 0
when "replay"
  cmd = ["rr", "replay", '-i=mi']
when "gdb"
  cmd = ["gdb", '-i=mi', ARGV[0]]
  args = ARGV[1..-1]
end

debug=false
#debug=true


class GDBMI
  class Input
    attr_accessor :token, :stdin, :debug
    def initialize(gdb_stdin)
      @token = 0
      @stdin = gdb_stdin
      @debug = false
    end
    def fmt(operation)
      "#{token}-#{operation} \n"
    end
    def exec(operation)
      puts "(exec): #{fmt(operation)}" if debug
      stdin.write(fmt(operation))
      @token+=1
    end
    def exec_start
      exec("exec-run")
    end
    def exec_arguments(args)
      exec("exec-arguments #{args.join(' ')}")
    end

    def exec_continue
      exec("exec-continue")
    end

    def data_eval_expr(expr)
      expr.gsub!('"', '\\"')
      exec("data-evaluate-expression \"#{expr}\"")
    end

    def break_insert(line, condition)
      condition.gsub!('"', '\\"')
      exec("break-insert -c \"#{condition}\" #{line}")
    end

    def gdb_set(expr)
      exec("gdb-set #{expr}")
    end

    def mrr_break_insert(file, line)
      break_insert("mrr_rr_hook", "$_streq(file, \"#{file}\") == 1 && line == #{line}")
    end

    def mrr_next
      gdb_set("$file = file")
      gdb_set("$line = line+1")
      break_insert("mrr_rr_hook", "$_streq((char*)file, $file) == 1 && line == $line")
      exec_continue
    end

    def mrr_eval(rb_expr)
      len = rb_expr.size
      rb_expr.gsub!('"', '\\"')
      expr = "mrr_cmd_print(mrb, dbg, \"#{rb_expr}\")"
      data_eval_expr(expr)
    end
  end
end

class RR
  class State
    attr_accessor :current_file, :current_line
    def current_line=(val)
      @current_line = val.to_i
    end
    def list(file=nil, line=nil, line_count=10)
      file ||= current_file
      line ||= current_line
      start_line = line - (line_count/2)
      end_line = start_line + line_count
      range = start_line..end_line
      File.open(file).each_line.with_index do |l,i|
        next unless range.include?(i)
        indicator = i == current_line ? "=>" : "  "
        puts "#{indicator} #{i}: #{l}"
      end
    end
  end
end

rr_state = RR::State.new
Open3.popen3(*cmd) do |stdin, stdout, stderr, wait_thr|
  Thread.new do
    loop do
      stderr.read
    end
  end
  Thread.new do
    loop do
      buf = stdout.readline.strip
      case buf
      when /^~.*/
        puts "(gdbout) #{buf}" if debug
      when /^=.*/
        puts "(gdbout) #{buf}" if debug
      when /^\(gdb\)$/
        nil
      else
        puts buf
      end
    end
  end
  mi_input = GDBMI::Input.new(stdin)
  while buf = Readline.readline("(mruby-rr) ", false)
    p "(input): #{buf}" if debug
    case buf.strip
    when "start"
      mi_input.exec_arguments(args) if mode == "gdb"
      mi_input.exec_start
    when "continue"
      mi_input.exec_continue
    when /break\s+([^\s]+)\s+(\d+)/
      rr_state.current_file = $1
      rr_state.current_line = $2
      mi_input.mrr_break_insert(rr_state.current_file, rr_state.current_line)
    when /eval\s+(.*)/
      mi_input.mrr_eval($1)
    when "next"
      mi_input.mrr_next
    when /^l(ist)?$/
      rr_state.list
    else
      stdin.puts(buf)
    end
  end
end
