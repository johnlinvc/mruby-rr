#!/usr/bin/env ruby
require 'open3'
require 'readline'
mode = ARGV.shift
case mode
when "record"
  cmd = ["rr", "record"] + ARGV
  system(*cmd)
  exit 0
when "replay"
  cmd = ["rr", "replay", '-i=mi']
when "gdb"
  cmd = ["gdb", '-i=mi', ARGV[0]]
  args = ARGV[1..-1]
end

debug=false
#debug=true


class GDBMI
  class Input
    attr_accessor :token, :stdin, :debug
    def initialize(gdb_stdin)
      @token = 0
      @stdin = gdb_stdin
      @debug = false
    end
    def fmt(operation)
      "#{token}-#{operation} \n"
    end
    def exec(operation)
      puts "(exec): #{fmt(operation)}" if debug
      stdin.write(fmt(operation))
      @token+=1
    end
    def exec_start
      exec("exec-run")
    end
    def exec_arguments(args)
      exec("exec-arguments #{args.join(' ')}")
    end

    def exec_continue
      exec("exec-continue")
    end

    def data_eval_expr(expr)
      expr.gsub!('"', '\\"')
      exec("data-evaluate-expression \"#{expr}\"")
    end

    def break_insert(line, condition)
      condition.gsub!('"', '\\"')
      exec("break-insert -c \"#{condition}\" #{line}")
    end

    def gdb_set(expr)
      exec("gdb-set #{expr}")
    end

    def mrr_break_insert(file, line)
      break_insert("mrr_rr_hook", "$_streq(file, \"#{file}\") == 1 && line == #{line}")
    end

    def mrr_next
      gdb_set("$file = file")
      gdb_set("$line = line+1")
      break_insert("mrr_rr_hook", "$_streq((char*)file, $file) == 1 && line == $line")
      exec_continue
    end

    def mrr_eval(rb_expr)
      len = rb_expr.size
      rb_expr.gsub!('"', '\\"')
      expr = "mrr_cmd_print(mrb, dbg, \"#{rb_expr}\")"
      data_eval_expr(expr)
    end
  end
end

class RR
  class State
    attr_accessor :current_file, :current_line, :prev_file, :prev_line
    def current_line=(val)
      @current_line = val.to_i
    end

    def initialize
      @mutex = Mutex.new
      @ready = false
    end

    def inspect
      puts "current_line: #{current_line}"
      puts "current_file: #{current_file}"
    end
    def list(file=nil, line=nil, line_count=10)
      file ||= current_file
      line ||= current_line
      start_line = line - (line_count/2)
      end_line = start_line + line_count
      range = start_line..end_line
      File.open(file).each_line.with_index do |l,i|
        j = i+1
        next unless range.include?(j)
        indicator = j == current_line ? "=>" : "  "
        puts "#{indicator} #{j}: #{l}"
      end
    end

    def get_frame(gdb_output)
    end

    def mark_not_ready!
      @mutex.synchronize {@ready = false}
    end

    def mark_ready!
      @mutex.synchronize {@ready = true}
    end

    def wait_till_ready
      loop do
        @mutex.synchronize {return if @ready}
        sleep 0.1
      end
    end

    def mutate(gdb_output)
      puts gdb_output if $debug
      case gdb_output
      when /^\*stopped,.*$/
        gdb_output =~ /name="file",value="0x\h+ \\"([^\\]+)\\""},{name="line",value="(\d+)"}/
        self.prev_file = self.current_file
        self.prev_line = self.current_line
        self.current_file = $1
        self.current_line = $2
        self.mark_ready!
      when /^\*running,.*/
        nil
      else
      end
      p self if $debug
    end
  end
end

rr_state = RR::State.new
Open3.popen3(*cmd) do |stdin, stdout, stderr, wait_thr|
  Thread.new do
    loop do
      stderr.read
    end
  end
  Thread.new do
    loop do
      buf = stdout.readline.strip
      case buf
      when /^~.*/
        puts "(gdbout) #{buf}" if debug
      when /^=.*/
        puts "(gdbout) #{buf}" if debug
      when /^\*.*$/
        rr_state.mutate(buf)
      when /^\(gdb\)$/
        nil
      when /^\d*\^.*/
        nil
      else
        puts buf
      end
    end
  end
  mi_input = GDBMI::Input.new(stdin)
  while buf = Readline.readline("(mruby-rr) ", false)
    p "(input): #{buf}" if debug
    case buf.strip
    when "start"
      rr_state.mark_not_ready!
      mi_input.exec_arguments(args) if mode == "gdb"
      mi_input.exec_start
      rr_state.wait_till_ready
    when "continue"
      rr_state.mark_not_ready!
      mi_input.exec_continue
      rr_state.wait_till_ready
    when /break\s+([^\s]+)\s+(\d+)/
      mi_input.mrr_break_insert($1, $2)
    when /eval\s+(.*)/
      mi_input.mrr_eval($1)
    when "next"
      mi_input.mrr_next
    when /^l(ist)?$/
      rr_state.list
    else
      stdin.puts(buf)
    end
  end
end
