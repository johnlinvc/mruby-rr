#!/usr/bin/env ruby
require 'open3'
require 'readline'
if ARGV[0] == "record"
elsif ARGV[0] == "replay"
elsif ARGV[0] == "gdb"
  cmd = ["gdb", '-i=mi', ARGV[1]]
end
debug=true


class GDBMI
  class Input
    attr_accessor :token, :stdin, :debug
    def initialize(gdb_stdin)
      @token = 0
      @stdin = gdb_stdin
      @debug = true
    end
    def fmt(operation)
      "#{token}-#{operation} \n"
    end
    def exec(operation)
      puts "(exec): #{fmt(operation)}" if debug
      stdin.write(fmt(operation))
      @token+=1
    end
    def exec_start
      exec("exec-run")
    end
    def exec_continue
      exec("exec-continue")
    end
    def break_insert(line, condition)
      condition.gsub!('"', '\\"')
      exec("break-insert -c \"#{condition}\" #{line}")
    end
    def mrr_break_insert(file, line)
      break_insert("mrr_rr_hook", "$_streq(file, \"#{file}\" == 1) && line == #{line}")
    end
  end
end

Open3.popen3(*cmd) do |stdin, stdout, stderr, wait_thr|
  Thread.new do
    loop do
      stderr.read
    end
  end
  Thread.new do
    loop do
      buf = stdout.readline
      if buf.start_with?("~")
        puts "(gdbout) #{buf}" if debug
      else
        puts buf
      end
    end
  end
  mi_input = GDBMI::Input.new(stdin)
  while buf = Readline.readline("(mruby-rr) ", false)
    p "(input): #{buf}" if debug
    case buf.strip
    when "start"
      mi_input.exec_start
    when "continue"
      mi_input.exec_continue
    when /break\s+([^\s]+)\s+(\d+)/
      mi_input.mrr_break_insert($1, $2)
    else
      stdin.puts(buf)
    end
  end
end
